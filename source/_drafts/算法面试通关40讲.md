---
title: 算法面试通关40讲
tags:
---

> 我还是要稍微的研究一下面试方面的算法题，我这里是极客时间的《算法面试通关40讲》的课程笔记

## Data Structure

## Algorithm

<!-- more -->

## 合格程序员的第一步：算法与数据结构

1. 算法就是内功，会决定你的知识的迁移能力
2. 是国内一流的大公司的必须要的技能，因为他们就是做轮子的人，你会用轮子的话，搞毛啊。
3. 能够让你更加容易地让你理解当前热门的技术

### 算法在生活中的应用

1. 找男女朋友
2. 工作安排，将优先级最高的事情放到一天最开始的时候做
3. 德州扑克
4. 区块链技术？？

### 关于比特币的稍微的内容

。。。

## 如何事半功倍地学习算法和数据结构

### 《异类》这本书中所说的学习一门技能的方法

### Chunk it up (切碎知识点)

### Deliberate practicing (刻意练习)

你一开始的时候可能会不舒服，没有躺着赚钱的方法，要与自己做斗争

### Feedback (反馈)

反馈一定要及时，例如你要看高手的代码，或者做leetcode也算是一种反馈

## 如何计算算法的复杂度

Big O notation

Master Theorem 用于评判递归算法的时间复杂度

## 如何通过LeetCode来进行算法题目练习

1. 你要做的不是你会做的题，而是你恰好不会做的题
2. 你要根据右边的Topic来做，一个一个类地攻破
3. 要关注时间复杂度
4. 机会永远给有准备的人

## 数组&链表

## 反转一个单链表&判断链表是否有环

## 树&二叉树&二叉搜索树

分层打印一棵二叉树

完全二叉树

## 验证二叉搜索树

二叉搜索树的特点就是左子树比当前结点小，右子树比当前结点大，然后呢，我们应该如何去验证一棵树是否是二叉搜索树？？

这道题的通常解法有两个

1. 一个是进行中序遍历，看看遍历出来的结点是否是单调递增的
2. 第二种方法是递归地拿出左右子树的最大以及最小的结点的值与当前结点进行比较，看看是否是符合条件

我感觉这两种方法都差不多，两个方法的时间复杂度都是O(n)

## 二叉树/二叉搜索树的最近公共祖先

> 我记得我做这道题的时候，我无法理解其中的写法

普通的二叉树的话，大致的方法有如下两点

1. 第一个方法就是将路径都记下来，这样要用一个数组来装这个路径
2. 第二个方法是递归看结点的左边跟右边是否有pq存在，当然，假如当前结点就是pq的其中之一，因为这道题是pq都肯定在树里面的，所以假如当前结点是pq之一，而且另一个就在当前结点的子树之中，那么当前结点就是最近公共祖先了。

假如是二叉排序树的话，当然是能有更加巧妙的方法了，因为二叉排序树里面的元素本来就是有序的。那么就可以直接用pq来跟root比较即可，一个大于root，一个小于root，那么root就必然是最近公共祖先了。

## 二叉树的遍历

其实前中后序遍历其实都用的比较少，当然这三种遍遍历我都很熟就是了，用的比较多的其实是深度优先与广度优先。

## 递归&分治

其实递归就是一种循环

《盗梦空间》可以了解一下

计算n的阶乘的递归

关于递归函数的模板，是可以有更多参数的

```python
def recursion(level, param1, param2):
    """
    关于递归函数的模板，是可以有更多参数的
    :param level:递归的层级
    :param param1:参数1
    :param param2:参数2
    :return:
    """

    # 递归的终止条件
    if level > MAX_LEVEL:
        print("result")
        return

    # 在这一层你所需要做的事情
    process_data(level, param1)

    # 进入下一层
    recursion(level + 1, param1, param2)

    # 回来的时候要做的事情
    reverse_state(level)
```

所谓分治能够解决的问题是，它没有重复子问题，假如有很多重复的运算，用动态规划会比较好。下面是关于分治问题的函数模板：

```python
def divide_conquer(problem, param1, param2):
    """
    关于分治问题的函数模板，可以更多参数
    :param problem:
    :param param1:
    :param param2:
    :return:
    """

    # 结束条件
    if problem is None:
        print('result')
        return

    # 准备数据，并将大问题转换为小问题
    data = prepare_data(problem)
    subproblems = split_problem(problem, data)

    # 对问题进行分治，并得出子结果
    subresult1 = divide_conquer(subproblems[0], param1, param2)
    subresult2 = divide_conquer(subproblems[1], param1, param2)
    subresult3 = divide_conquer(subproblems[2], param1, param2)

    # 将子结果进行合并再返回
    result = process_result(subresult1, subresult2, subresult3)
    return result
```

## 求x的n次方

我一开始的时候就直接用迭代的方式暴力求取了，谁知道超时了，然后用分治的方法才勉强AC

方法：

1. 库函数，这道题就是要考你啊，你用库函数搞毛
2. 暴力迭代，乘到最后，时间复杂度O(n)
3. 分治，有递归写法异界循环迭代写法，时间复杂度O(log(n))

注意：这里的n要考虑到三种情况，大于零，小于零，等于零

## 求众数

我这里使用了map来对数字计数，怎么还是这么慢呢？

## 贪心算法

不太能解决生活中的大部分实际问题。适用贪心算法的场景是问题能够分解成子问题来解决，子问题的最优解能够递推到最终问题的最优解，这种子问题最优解成为最优子结构。


