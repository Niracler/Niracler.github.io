---
title: 面试题|Python基础(一)
tags:
  - python
  - 面试题
date: 2019-10-13 21:34:44
---


## Python基础

### 1 为什么学习Python

那是一个很长的故事。本来我也只是想将Python作为第二语言的。自从我买了个阿里云服务器之后，就洪水泛滥，一发不可收拾了。

### 2 通过什么途径学习Python

我是自学的，上网找教程自学的，不过每一个教程我都只是看了一部分，基本上都没有看完。大一下学期的时候看的是小甲鱼的Python教程，大二上学期的时候，看的是一篇使用django搭建个人博客的博客，以及一个叫自强学堂的网站，大二下学期看的是北京理工大学的爬虫基础教程，大三上学期是学习机器学习的相关算法这段时间看视频看得比较少，学校课程也比较重，大三下学期强化了pandas等数据处理的库，以及sklean等机器学习的相关库，然后大三的暑假开始尝试使用上面说到的这些技术栈来做我自己的毕业设计。其实我一开始是没有想着只从事Python方面的学习的，只是各种阴差阳错。

### 3 公司线上和开发环境使用的什么系统

我们学校这边办公室的开发环境与服务器的线上环境用的都是Linux，开发环境用的是Manjaro的发行版，而服务器用的是Centos的发行版。使用Win也是完全没有问题的。

<!-- more -->

### 4 Python 和 Java PHP C C# C++ 等其他语言的对比

~~总的来说,Python 会使用起来比较简单吧，但是性能会比上面所说的那些语言要低。是一种灵活性非常高的语言。Python是一种解释型的语言，而其他几种都是编译型的语言，写好代码之后需要经过编译才能运行。当然，Python好像也是可以编译的。~~

Python 与 PHP 属于解释型语言,运行的时候是一行一行解释并运行。而C,Java,C#,C++ 都是编译型语言,需要经过编译才能运行.

与Java相比：在很多方面，Python比Java要简单，比如Java中所有变量必须声明才能使用，而Python不需要声明，用少量代码就可以构建出很多功能;(高效的高级数据结构)

与PHP相比：Python标准包直接提供了工具，并且相对于PHP代码更容易维护

与C相比：

Python这门语言是由C开发而来。在使用方面，Python的类库齐全并且使用简洁,如果要实现同样的功能,Python 10行代码可以解决,C可能就需要100行甚至更多。在速度方面，Python的运行速度相较与C,绝逼是慢了。但是具体相比较而言慢多少我是没有比较过的。

Python特点以及优势：

1. 语法简洁优美
2. 功能强大,开发效率高
3. 标准库与第三方库都非常强大
4. 应用领域也非常广
5. 可移植性，可扩展性，可嵌入性

### 5 Python解释器种类及其特点

CPython是官方版本的解释器，使用C语言开发，所以叫CPython。在命令行下运行Python就是启动CPython解释器，是使用最广的Python解释器。

IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能是和CPython是完全一样的。CPython用>>作为提示符，而IPython使用In[序号]:作为提示符。

PyPy是由Python写的解释器,它的执行速度是最快。PyPy采用JIT技术,对Python代码进行动态编译(注意不是解释),绝大部分Python代码都可以在PyPy下运行,但是PyPy和CPython有一些是不同的,这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。

Jython是运行在Java平台上的Python解释器,可以直接把Python代码编译成Java字节码执行。

IronPython和Jython类似,只不过IronPython是运行在.Net平台上的Python解释器,可以直接把Python代码编译成.Net的字节码。

小结:
Python的解释器很多,但使用最广泛的还是CPython。如果要和Java或.Net平台交互,最好的办法不是用Jython或IronPython,而是通过网络调用来交互,确保各程序之间的独立性。

### 6 位和字节的关系

8字节等于1位。

数据传输是以字节为单位，而数据传输大多是以位为单位。一个位就代表一个0或1，是构成存储器的最小单位。而2每8位组成一个字节，字节是最小一级的信息单位。

### 7 b,B,KB,MB,GB的关系

1GB = 2^10MB = 2^20KB = 2^30B = 8 * 2^30b

### 8 至少举例5个PEP8规范(越多越好)

1. 使用四个空格而不是tab进行缩进
2. 每行长度不能超过79
3. 使用空格来间隔函数和类，以及函数内部的大块代码
4. 必要时候，在每一行下写注释
5. 使用文档注释，写出函数注释
6. 在操作符和逗号之后使用空格，但不要在括号内部使用
7. 命名类和函数的时候使用一致的方式，比如使用CamelCase来命名类,使用lower_case_with_underscores来命名函数和方法
8. 在类中总是使用self来作为默认
9. 尽量不要使用魔法方法
10. 默认使用UTF-8,甚至是ASCII作为编码方式
11. 换行可以使用反斜杠，最好使用圆括号
12. 尽量不要使用魔法方法
13. 不要在一句中 import 多个库
14. 函数命名使用全部小写的方式，常量命名使用大写，类属性(方法和变量)使用小写，类的命名首字母大写。

关于空格的使用

1. 各种右括号前不要加空格
2. 逗号，冒号，分号前不要加空格
3. 函数的左括号前不要加空格
4. 序列的左括号前不要加空格
5. 操作副左右各加一个空格，不要为了对齐增加空格
6. 函数默认参数使用的赋值符左右省略空格
7. 不要将多句语句写在同一行，尽管使用‘;’允许
8. if/for/while语句中，即使执行语句只有一行，也必须另起一行

### 9 求结果： or and

```python
v1 = 1 or 3
v2 = 1 and 3
v3 = 0 and 2 and 1
v4 = 0 and 2 or 1
v5 = 0 and 2 or 1 or 4
v6 = 0 or False and 3

print(v1) # 1
print(v2) # 3
print(v3) # 0
print(v4) # 1
print(v5) # 1
print(v6) # False
```

总结:

- x or y 如果x为真，则值为x，否则为y
- x and y 如果x为真，则值为y，否则为x
- 从右到左

### 10 简述解释型和编译型语言

解释型语言:是运行的时候一行一行地解释运行。
编译型语言:需要写好代码后，先经过编译阶段，然后才能执行。

### 11 ascii, unicode, utf-8, gbk 的区别

Python2内容进行编码的默认为ascii，而Python3对内容进行编码的默认为utf-8

ascii 最多只能用八位来表示，即一个字节，所以 ASCII 码最多只能表示256个字符

unicode 万国码，任何一个字符等于两个字节

utf-8 万国码的升级版，一个中文字符等于三个字节，英文是一个字节，欧洲的是两个字节

gbk 国内版本，一个中文字符等于两个字节，英文是一个字节

gbk转utf-8 需要通过媒介 unicode

### 12 字节码和机器码的区别

- 机器码是电脑CPU可以直接解读的数据  
- 字节码是一种中间状态的二进制代码。需要直译器转译之后才能成为机器码

### 13 三元运算符编写格式

结果1 if 条件 else 结果2  
如果条件为真,把if前面的值赋值给变量,否则把else后面的值赋值给变量。例子：

```python

res = 'gt' if 1 > 3 else 'it'
print(res)
```

### 14 列举你了解的所有 Python2 和 Python3 的区别

~~1. print 是否需要括号~~
~~2. 因为我没有使用过Python2,所以这方面我不太了解~~

1. print时，py2可以不需要加括号，而py3必须要加括号
2. exec语句被py3废弃，统一使用exec函数
3. py2臃肿，源码重复量大，语法不清晰，掺杂者C，PHP，Java的一些陋习
4. py2几乎是重构后的源码，规范，清晰，优美
5. py2要输出中文，需要加 ```# -*- encoding:utf-8 -*-```，py3则不需要，可以直接使用
6. py2使用raw_input,而py3统一使用input函数
7. file函数统一被py3废弃，统一使用open来处理文件，可以通过io.IOBase检查文件类型
8. 字典变量has_key被Py3废弃，统一使用in关键词
9. 异常 StandardError 被 py3 废弃，统一使用 Exception
10. 迭代器 iterator 的 next() 函数被 Py3 废弃，统一使用 next(iterator)
11. long 整数类型被 Py3 废弃，统一使用 int
12. 不相等操作符 ```<>``` 被Py3废弃，统一使用 ```!=```
13. Py2中模块文件的集合必须有 __init__ ,Py3 则不必须
14. Py3 统一使用 range,Python3 中 range 的机制也进行修改并提高了大数据集生成效率

### 15 Py2 项目如何迁移成 Py3

应该会有相应的工具吧，上网搜搜？？

### 16 用一行代码实现数值交换

```python
a = 1
b = 2

a,b = b,a
```

### 17 Python3 和 Python2 中 int 和 long 的区别

Python3 中没有 long，只有一种整数类型 int, 大多数情况下，和 Py2 中的长整型类似

### 18 xrange 和 range 的区别

都是在循环时使用，xrange内存性能更好，xrange 与 range 用法完全相同，range 一个生成 list 对象，而 xrange 是生成器。要生成很大的数字序列的时候，用 xrange 会比 range 性能优很多，因为不需要一上来就开辟一块很大的内存空间。

在 Py3 中，range() 是像 xrange() 那样实现， xrange() 被抛弃

### 19 如何实现字符串的反转

如：name = "wupeiqi" 请反转为 name = "iqiepuw"

```python
name[::-1]
```

### 20 文件操作时：xreadlines 和 readlines 的区别

- readlines 返回的是一个列表
- xreadlines 返回的是一个生成器

### 21 列举布尔值为 False 的常见值

0, "", {}, [], (), set(), False, 负数, 不成立的表达式, None等

### 22 列举字符串，列表，元组，字典每个常用的五个方法

字符串：count,encode,format,find,isdigit

列表:append,insert,pop,remove,extend

元组:count,index,压根没有这么多方法

字典：get,keys,values

### 23 is 和 == 的区别

is 比较的是内存地址，==比较的是值

### 24 1,2,3,4,5 能组成多少个互不相同且无重复的三位数

好吧 你说我能不能 111？？

### 25 什么是反射？以及其应用场景

### 26 简述Python的深浅拷贝

- 浅拷贝只是增加了一个指针指向一个存在的内存空间
- 而深拷贝是增加一个指针并开辟了新的内存，这个增加的指针指向这个新的内存
- 采用浅拷贝的情况，释放内存会一同释放内存,深拷贝就不会出现释放同一内存的错误

### 27 Python 垃圾回收机制

- 指针计数
- 标记清楚
- 分代回收

### 28 Python 的可变类型和不可变类型的区别

- 可变数据类型:列表、字典、可变集合
- 不可变数据类型:数字、字符串、元组、不可变集合

### 29 求结果

```python
v = dict.fromkeys(['k1','k2'],[])
v['k1'].append(666)
print(v)
v['k1'] = 777
print(v)
```

~~{'k1':[666], 'k2':[]}~~  
~~{'k1':777, 'k2':[]}~~

结果:  
{'k1': [666], 'k2': [666]}  
{'k1': 777, 'k2': [666]}  

解释:  
Python 字典(Dictionary) fromkeys() 函数用于创建一个新字典,以序列seq中元素做字典的键,value为字典所有键
对应的初始值,默认为None。

### 30 一行代码实现删除列表中重复的值

~~这个真的挺有难度的，等等~~

没有比这更简单的了

```python
a = [64,3,5,4,8,4,34,83,45,48,3,3,513,8]
list(set(a))
```

### 31 如何实现"1,2,3"变成['1','2','3']

```python
"1,2,3".split(',')
```

### 32 如何实现['1','2','3'] 变成 [1, 2, 3]

```python
[int(i) for i in res]
```

### 33 比较: a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 c = [(1,),(2,),(3,) ] 的区别

### 34 如何用一行代码生成[1,4,9,16,25,36,49,64,81,100]

```python
[i**2 for i in range(1,11)]
```

### 35 常用字符串格式化哪几种

字符串格式化的方法主要有两种

1. 占位符 %

```python
print('Hello, %s' % 'Python')
print('Hello, %d %s %.2f' % (666, 'Python', 9.99999))
```

2. format

```python
print('{k} is {v}'.format(k='python', v='easy'))
print('{0} is {1}'.format('python', 'easy'))
```